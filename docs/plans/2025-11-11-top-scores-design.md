# Top 100 Scores Feature Design

## Backend API & Ranking Logic
We will expose a dedicated FastAPI route `GET /api/top-scores` that centralizes all ranking logic. Required query params: `assessment` (`act` or `iar`) and `level` (`high`, `middle`, `elementary`). Optional `limit` defaults to 100 and is capped at 100 to keep payloads small; invalid params trigger 422 responses. The SQLAlchemy `School` model already includes ACT metrics and `school_type`, but we will add nullable Float columns for the IAR `% Meets/Exceeds` composite (overall plus subject-level fields if needed) so the import job can persist them. During import we normalize `school_type` strings into one of three canonical levels (e.g., “Elem/Middle School” → `elementary`) and store the normalized level in the existing `level` column for fast filtering.

The ranking query filters by `level`, excludes rows with `NULL` or zero scores, sorts by the relevant metric descending, and applies a deterministic secondary sort (`school_name ASC`) to keep responses stable even when scores tie. For ACT we compute the ordering value in SQL as `avg(act_ela_avg, act_math_avg)` while still returning both subjects so the `ACTScores` schema can derive `overall_avg`. For IAR we sort by the stored composite `% Meets/Exceeds`. The endpoint returns a `TopScoreEntry` list containing `rank` (1-indexed based on list order), `rcdts`, `school_name`, `city`, `district`, `school_type`, `score`, and `enrollment`. We reuse Pydantic for validation/serialization and add pytest coverage for: param validation, level filtering, null exclusion, tie stability, and ensuring at most `limit` entries are returned. Caching is unnecessary initially, but the service layer is structured so we can add in-memory caching if queries become expensive.

## Frontend Routing & UI Structure
The homepage gains a new full-width CTA card directly under the search input. Styled with shadcn/ui `Card` + Tailwind utilities, it includes a bold title (“Explore Top 100 School Scores”), short supporting text, and an icon. On desktop it spans the search container width; on mobile it stacks naturally with padding and prominent tap targets (min height 64px). Clicking the card routes via React Router to a new `/top-scores` page component that loads immediately; no modal overlays are used. The page contains: (1) hero heading + description, (2) optional callout summarizing the methodology, and (3) a tabbed interface implemented via shadcn/ui `Tabs` with triggers “High School ACT”, “Middle School IAR”, and “Elementary IAR”. Each tab wraps a scrollable `Card` whose height adapts to viewport (e.g., `max-h-[70vh] overflow-y-auto` on desktop, full height stacked on mobile). Lists show rank number, school name, district (muted text), city, score badge, enrollment, and a chevron button that links to `/schools/:rcdts`. Row layout uses CSS grid on desktop (rank / name+meta / score / action) and collapses into stacked blocks on small screens while preserving touch-friendly spacing. Loading states show skeleton rows; empty/error states display friendly messages with retry buttons. The page reuses TanStack Query hooks with query keys like `['top-scores', assessment, level]` and prefetches the next tab’s data on hover/focus for snappy switching.

## Interaction, Accessibility & Testing Strategy
Each row behaves like a button: full-row click navigates to the school detail view while still providing a focus outline for keyboard users. Tabs are proper `<button role="tab">` elements, and ARIA attributes ensure screen readers announce the selected assessment/level. Scores display as percentages (IAR) or precise averages (ACT overall, with tooltip showing subject breakdown). We add a compact legend explaining what ACT overall and IAR % Meets/Exceeds mean, plus a note about tie handling. On mobile we keep typography at 16px+ and ensure scroll containers use `scroll-margin-top` so tab focus doesn’t hide content beneath a sticky header. Performance-wise, each tab fetch is limited to 100 rows (~15 KB JSON), and we memoize row components to avoid unnecessary renders while scrolling. TanStack Query handles caching, stale times, and refetch-on-focus; we respect the user’s offline mode by surfacing cached results if available.

Testing: Backend pytest cases cover endpoint validation, ordering, and field presence. Frontend adds Vitest component tests for the CTA, tab switching logic, and rendering of ranked rows given mocked query data. We also add a Playwright spec that navigates from the homepage CTA to `/top-scores`, verifies tab toggling, ensures lists contain 100 or fewer rows, and checks that clicking a school routes to its detail page. Accessibility audits (Storybook/axe or Playwright + axe) ensure contrast and keyboard traps are handled. This design keeps implementation incremental: build the CTA and route shell, wire the backend endpoint, then style the list per tab, guaranteeing a mobile-first, accessible experience.
